# -*- coding: utf-8 -*-
"""learned_index_1dint.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1zAansNiJACI0g66cygIon60DZ8WCEhxm

# Read dataset

## read data
"""

import codecs
import os
minkey=1000
maxkey=9999
keynum=3000
current_path=os.path.abspath(os.curdir)
f=codecs.open(os.path.join(current_path,"data.csv"), "r", "utf-8")
strlist=f.read().split("\n")
f.close()
trainkeys=[]
trainres=[]
for ele in strlist:
    temp=ele.split(",")
    if len(temp)!=2:
        continue
    trainkeys.append(int(temp[0]))
    trainres.append(int(temp[1]))
# f=codecs.open(os.path.join(current_path,"data_dev.csv"), "r", "utf-8")
# strlist=f.read().split("\n")
# f.close()
# devkeys=[]
# devres=[]
# for ele in strlist:
#     temp=ele.split(",")
#     if len(temp)!=2:
#         continue
#     devkeys.append(int(temp[0]))
#     devres.append(int(temp[1]))
f=codecs.open(os.path.join(current_path,"data_test.csv"), "r", "utf-8")
strlist=f.read().split("\n")
f.close()
testkeys=[]
testres=[]
for ele in strlist:
    temp=ele.split(",")
    if len(temp)!=2:
        continue
    testkeys.append(int(temp[0]))
    testres.append(int(temp[1]))

# It is very time and space consuming to build models based on the entire dataset
# Instead, we divide the dataset into 3 parts (training, dev, testing)
# We build and train models based on training set, and give index predictions based on testing set

# trainkeys.extend(devkeys)
# trainres.extend(devres)
# trainkeys.extend(testkeys)
# trainres.extend(testres)

print("training data size:",len(trainkeys))
# print("development data size:",len(devkeys))
print("testing data size:",len(testkeys))

"""# Build Models"""

trainpages=[]
for ele in trainres:
  trainpages.append(ele//100)
testpages=[]
for ele in testres:
  testpages.append(ele//100)

import numpy as np
X_train=np.array(trainkeys).reshape(-1,1)
Y_train=np.array(trainres).reshape(-1,1)
Z_train=np.array(trainpages).reshape(-1,1)
X_test=np.array(testkeys).reshape(-1,1)
Y_test=np.array(testres).reshape(-1,1)
Z_test=np.array(testpages).reshape(-1,1)

import warnings
from sklearn.exceptions import DataConversionWarning
warnings.filterwarnings(action='ignore', category=DataConversionWarning)

"""## B-Tree"""

#This is a B-Tree model
#reference: https://www.jianshu.com/p/c625a009e488
from random import shuffle
import random
import os
import codecs
import numpy as np
import math
import time
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error 
mse_BTree=0.0
root_node = None
# trainkeys=[]
# trainres=[]
# devkeys=[]
# devres=[]
# testkeys=[]
# testres=[]
class Logger(object):
    @classmethod
    def tree(cls, node, child_name, dsc, depth):
        if depth == 0:
            head = "|   " * depth
            print(head + "+--" + dsc(node))
            depth = depth + 1
        for child in getattr(node, child_name):
            head = "|   " * depth
            print(head + "+--" + dsc(child))
            cls.tree(child, child_name, dsc, depth + 1)
class BKeyword(object):
    def __init__(self, key, loc):
        self.key = key
        self.loc = loc
class BNode(object):
    def __init__(self,M):
        self._parent: BNode = None
        self.keywords = []
        self.child_nodes = []
        self.M=M
    # set parent node
    def set_parent(self, node):
        self._parent = node
        if node.get_parent() is None:
            global root_node
            root_node = node.get_parent()
    # get parent node
    def get_parent(self):
        return self._parent
    # add child node to right location
    def insert_child_node(self, index, add_node):
        add_node.set_parent(self)
        self.child_nodes.insert(index, add_node)
    # add child node
    def append_child_node(self, add_node):
        add_node.set_parent(self)
        self.child_nodes.append(add_node)
    # find right insertion location
    def find_add_index(self, add_word):
        if len(self.keywords) == 0:
            return 0
        index = 0
        while True:
            if index >= len(self.keywords):
                break
            key = self.keywords[index].key
            if add_word.key < key:
                break
            index = index + 1
        return index
	#find the location of given keyword
    def find_loc(self,word):
        if len(self.keywords) == 0:
            return -1
        index = 0
        key=-1
        while True:
            if index >= len(self.keywords):
                break
            key = self.keywords[index].key
            if word < key:
                break
            index = index + 1
        if index==0:
            index=1
        index=index-1
        #print(index)
        if index+1>=len(self.keywords):
            return int(self.keywords[index].loc)
        if self.keywords[index].key==word or abs(int(word)-int(self.keywords[index].key))<abs(int(word)-int(self.keywords[index+1].key)):
            return int(self.keywords[index].loc)
        else:
            return int(self.keywords[index+1].loc)
    # insert data to right location (regardless of M)
    def blind_add(self, word: BKeyword) -> int:
        index = self.find_add_index(word)
        self.keywords.insert(index, word)
    def split(self):
        # split node
        parent, center_keyword, left_node, right_node = self.split_to_piece()
        # add two new nodes as parent, build relationship
        parent_add_index = parent.find_add_index(center_keyword)
        parent.insert_child_node(parent_add_index, right_node)
        parent.insert_child_node(parent_add_index, left_node)
        # remove itself
        if self in parent.child_nodes:
            parent.child_nodes.remove(self)
        parent.add_word(center_keyword, force=True)
        # redefine root
        root = self
        while root.get_parent() is not None:
            root = root.get_parent()
        global root_node
        root_node = root
    def split_to_piece(self):
        center_keyword = self.keywords[int((self.M-1)/2)]
        if self.get_parent() is None:
            self.set_parent(BNode(self.M))
        left_node = BNode(self.M)
        right_node = BNode(self.M)
        for keyword in self.keywords:
            if keyword.key < center_keyword.key:
                left_node.keywords.append(keyword)
            elif keyword.key > center_keyword.key:
                right_node.keywords.append(keyword)
        for i in range(len(self.child_nodes)):
            if i <= int((len(self.child_nodes) - 1)/2):
                left_node.append_child_node(self.child_nodes[i])
            else:
                right_node.append_child_node(self.child_nodes[i])
        return self.get_parent(), center_keyword, left_node, right_node
    def add_word(self, keyword, force=False):
        if len(self.child_nodes) == 0 or force:
            self.blind_add(keyword)
            if len(self.keywords) == self.M:
                self.split()
        else:

            index = self.find_add_index(keyword)
            if index >= len(self.child_nodes):
                index = index - 1
            self.child_nodes[index].add_word(keyword)
def B_Tree_Model():
    # print("Simple B-Tree Model")
    t1=time.time()
    root_node=BNode(4)
    for i in range(0,len(trainkeys)):
        keyword=BKeyword(trainkeys[i],trainres[i])
        root_node.add_word(keyword)
    t2=time.time()
    time_interval=t2-t1
    print("time interval for building model:"+str(time_interval*1000)+" ms")
    # devpre=[]
    # for i in range(0,len(devkeys)):
    #     devpre.append(root_node.find_loc(devkeys[i]))
    # global mse_BTree
    # mse_BTree=mean_squared_error(devres,devpre)
    # print("log MSE dev: ",round(math.log(1+mse_BTree,2),3))
    t1=time.time()
    testpre=[]
    for i in range(0,len(testkeys)):
        testpre.append(root_node.find_loc(testkeys[i]))
    t2=time.time()
    time_interval=t2-t1
    print("time interval for indexing data :"+str(time_interval*1000)+" ms")
    print("average time interval for indexing data :"+str(time_interval/len(testkeys)*1000)+" ms")
    # print("log MSE test: ",round(math.log(1+mean_squared_error(testres,testpre),2),3))
    return
if __name__ == '__main__':
    # f=codecs.open(os.path.join(current_path,"data_train.csv"), "r", "utf-8")
    # strlist=f.read().split("\n")
    # f.close()
    # trainkeys=[]
    # trainres=[]
    # for ele in strlist:
    #     temp=ele.split(",")
    #     if len(temp)!=2:
    #         continue
    #     trainkeys.append(int(temp[0]))
    #     trainres.append(int(temp[1]))
    # f=codecs.open(os.path.join(current_path,"data_dev.csv"), "r", "utf-8")
    # strlist=f.read().split("\n")
    # f.close()
    # devkeys=[]
    # devres=[]
    # for ele in strlist:
    #     temp=ele.split(",")
    #     if len(temp)!=2:
    #         continue
    #     devkeys.append(int(temp[0]))
    #     devres.append(int(temp[1]))
    # f=codecs.open(os.path.join(current_path,"data_test.csv"), "r", "utf-8")
    # strlist=f.read().split("\n")
    # f.close()
    # testkeys=[]
    # testres=[]
    # for ele in strlist:
    #     temp=ele.split(",")
    #     if len(temp)!=2:
    #         continue
    #     testkeys.append(int(temp[0]))
    #     testres.append(int(temp[1]))
    B_Tree_Model()

"""## Linear Regression"""

from sklearn.linear_model import LinearRegression
import numpy as np
from sklearn.metrics import mean_squared_error 
import math
import time
# print("Linear Regression Model")
t1=time.time()
reg = LinearRegression()
reg.fit(X_train,Y_train)
t2=time.time()
time_interval=t2-t1
print("time interval for building model:"+str(time_interval*1000)+" ms")
# devpre=reg.predict(np.array(devkeys).reshape(-1,1)).reshape(1,-1).tolist()[0]
# for i in range(0,len(devpre)):
#     devpre[i]=abs(int(devpre[i]))
# mse_LR=mean_squared_error(devres,devpre)
# print("MSE dev: ",mse_LR)
t1=time.time()
testpre=reg.predict(X_test).reshape(1,-1).tolist()[0]
for i in range(0,len(testpre)):
  testpre[i]=abs(int(testpre[i]))
t2=time.time()
time_interval=t2-t1
print("time interval for indexing data :"+str(time_interval*1000)+" ms")
print("average time interval for indexing data :"+str(time_interval/len(testkeys)*1000)+" ms")
# print("log MSE test: ",round(math.log(1+mean_squared_error(testres,testpre),2),3))
t1=time.time()
count_error=0
for i in range(0,len(testpre)):
  estimated_loc=testpre[i]
  correct_res=testkeys[i]
  if estimated_loc>=0 and estimated_loc<len(trainkeys):
    finding_res=trainkeys[estimated_loc]
  elif estimated_loc<0:
    finding_res=trainkeys[0]
  else:
    finding_res=trainkeys[len(trainkeys)-1]
  while finding_res!=correct_res:
    count_error+=1
    if finding_res<correct_res:
      estimated_loc+=1
      if estimated_loc>=0 and estimated_loc<len(trainkeys):
        finding_res=trainkeys[estimated_loc]
      elif estimated_loc<0:
        finding_res=trainkeys[0]
      else:
        finding_res=trainkeys[len(trainkeys)-1]
    else:
      estimated_loc-=1
      if estimated_loc>=0 and estimated_loc<len(trainkeys):
        finding_res=trainkeys[estimated_loc]
      elif estimated_loc<0:
        finding_res=trainkeys[0]
      else:
        finding_res=trainkeys[len(trainkeys)-1]
t2=time.time()
time_interval=t2-t1
print("time interval for error correction :"+str(time_interval*1000)+" ms")
print("average time interval for error correction :"+str(time_interval/count_error*1000)+" ms")

"""## KNN"""

from sklearn.neighbors import KNeighborsClassifier
import time
import numpy as np
from sklearn.metrics import classification_report
t1=time.time()
neigh = KNeighborsClassifier(n_neighbors=9)
neigh.fit(X_train,Z_train)
t2=time.time()
time_interval=t2-t1
# devpre=neigh.predict(X_dev)#.reshape(1,-1).tolist()[0]
# print(classification_report(Y_dev,devpre))
print("time interval for building model:"+str(time_interval*1000)+" ms")
t1=time.time()
testpre=neigh.predict(X_test).reshape(1,-1).tolist()[0]
t2=time.time()
time_interval=t2-t1
print("time interval for indexing data :"+str(time_interval*1000)+" ms")
print("average time interval for indexing data :"+str(time_interval/len(testkeys)*1000)+" ms")
t1=time.time()
for i in range(0,len(testpre)):
  estimated_page=testpre[i]
  correct_res=testkeys[i]
  if correct_res in range(estimated_page*100,estimated_page*100+100):
    pass
  else:
    estimated_page=correct_res//100
  begin=estimated_page*100
  end=estimated_page*100+100
  while begin<end:
    middle=(begin+end)//2
    if middle==correct_res:
      estimated_loc=middle
      break
    elif middle<correct_res:
      begin=middle
    else:
      end=middle
t2=time.time()
time_interval=t2-t1
print("time interval for error correction :"+str(time_interval*1000)+" ms")
print("average time interval for error correction :"+str(time_interval/len(testkeys)*1000)+" ms")

"""## Naive Bayes"""

from sklearn.naive_bayes import GaussianNB
import time
import numpy as np
from sklearn.metrics import classification_report
t1=time.time()
NB = GaussianNB()
NB.fit(X_train,Z_train)
t2=time.time()
time_interval=t2-t1
# devpre=NB.predict(X_dev)#.reshape(1,-1).tolist()[0]
# print(classification_report(Y_dev,devpre))
print("time interval for building model:"+str(time_interval*1000)+" ms")
t1=time.time()
testpre=NB.predict(X_test).reshape(1,-1).tolist()[0]
t2=time.time()
time_interval=t2-t1
print("time interval for indexing data :"+str(time_interval*1000)+" ms")
print("average time interval for indexing data :"+str(time_interval/len(testkeys)*1000)+" ms")
t1=time.time()
for i in range(0,len(testpre)):
  estimated_page=testpre[i]
  correct_res=testkeys[i]
  if correct_res in range(estimated_page*100,estimated_page*100+100):
    pass
  else:
    estimated_page=correct_res//100
  begin=estimated_page*100
  end=estimated_page*100+100
  while begin<end:
    middle=(begin+end)//2
    if middle==correct_res:
      estimated_loc=middle
      break
    elif middle<correct_res:
      begin=middle
    else:
      end=middle
t2=time.time()
time_interval=t2-t1
print("time interval for error correction :"+str(time_interval*1000)+" ms")
print("average time interval for error correction :"+str(time_interval/len(testkeys)*1000)+" ms")

"""## Decision Tree"""

from sklearn import tree
import time
import numpy as np
from sklearn.metrics import classification_report
t1=time.time()
tree = tree.DecisionTreeClassifier()
tree.fit(X_train,Z_train)
t2=time.time()
time_interval=t2-t1
# devpre=tree.predict(X_dev)#.reshape(1,-1).tolist()[0]
# print(classification_report(Y_dev,devpre))
print("time interval for building model:"+str(time_interval*1000)+" ms")
t1=time.time()
testpre=tree.predict(X_test).reshape(1,-1).tolist()[0]
t2=time.time()
time_interval=t2-t1
print("time interval for indexing data :"+str(time_interval*1000)+" ms")
print("average time interval for indexing data :"+str(time_interval/len(testkeys)*1000)+" ms")
t1=time.time()
for i in range(0,len(testpre)):
  estimated_page=testpre[i]
  correct_res=testkeys[i]
  if correct_res in range(estimated_page*100,estimated_page*100+100):
    pass
  else:
    estimated_page=correct_res//100
  begin=estimated_page*100
  end=estimated_page*100+100
  while begin<end:
    middle=(begin+end)//2
    if middle==correct_res:
      estimated_loc=middle
      break
    elif middle<correct_res:
      begin=middle
    else:
      end=middle
t2=time.time()
time_interval=t2-t1
print("time interval for error correction :"+str(time_interval*1000)+" ms")
print("average time interval for error correction :"+str(time_interval/len(testkeys)*1000)+" ms")