# -*- coding: utf-8 -*-
"""leaned_index_regression.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1F75Z9HYdbhG5weobUpc7JVG8SeypSJKg

Author: Xinnan Shen<br>
Date: 05-05-2020

# Learned Index Model Simple Demo
This notebook is to build some simple learned index models based on Kraska's paper.

## Step 1: Generate some simple dataset in csv format
"""

import os
import codecs
import random
#function: data_generation
#usage: generate a simple dataset
#parameters:
#1.len_num: the size of dataset
#2.range_min: the minimum key
#3.range_max: the maximun key
#output dataset: two columns (key,location)
def data_generation(len_num,range_min,range_max):
	dataset=set()
	for i in range(0,len_num):
		x=random.randint(range_min,range_max)
		while x in dataset:
			x=random.randint(range_min,range_max)
		dataset.add(x)
	# for i in range(0,len(datalist)):
	# 	temp=False
	# 	for j in range(0,len(datalist)-i-1):
	# 		if datalist[j]>datalist[j+1]:
	# 			t=datalist[j]
	# 			datalist[j]=datalist[j+1]
	# 			datalist[j+1]=t
	# 			temp=True
	# 	if not temp:
	# 		break
	current_path=os.path.abspath(os.curdir)
	f=codecs.open(os.path.join(current_path,"data.csv"), "w", "utf-8")
	i=0
	datalist=list(dataset)
	datalist.sort()
	for ele in datalist:
		f.write(str(ele)+","+str(i)+"\n")
		i=i+1
	f.close()
	return

"""- Provide some value and generate the dataset"""

minkey=0
maxkey=2147483647
keynum=500000
data_generation(keynum,minkey,maxkey)

"""## Step 2: Split the dataset into training, development and testing dataset"""

from random import shuffle
import numpy as np
from sklearn.model_selection import train_test_split
current_path=os.path.abspath(os.curdir)
f=codecs.open(os.path.join(current_path,"data.csv"), "r", "utf-8")
strlist=f.read().split("\n")
f.close()
list_key=[]
list_res=[]
for ele in strlist:
    temp=ele.split(",")
    if len(temp)!=2:
        continue
    list_key.append(temp[0])
    list_res.append(temp[1])
keys=np.array(list_key)
res=np.array(list_res)
trainkeys,testkeys,trainres,testres=train_test_split(keys,res,test_size=0.35)
trainkeys,devkeys,trainres,devres=train_test_split(trainkeys,trainres,test_size=0.5)
trainkeys=list(trainkeys)
devkeys=list(devkeys)
testkeys=list(testkeys)
trainres=list(trainres)
devres=list(devres)
testres=list(testres)

f=codecs.open(os.path.join(current_path,"data_train.csv"), "w", "utf-8")
for i in range(0,len(trainkeys)):
    f.write(str(trainkeys[i])+","+str(trainres[i])+"\n")
f.close()
f=codecs.open(os.path.join(current_path,"data_dev.csv"), "w", "utf-8")
for i in range(0,len(devkeys)):
    f.write(str(devkeys[i])+","+str(devres[i])+"\n")
f.close()
f=codecs.open(os.path.join(current_path,"data_test.csv"), "w", "utf-8")
for i in range(0,len(testkeys)):
    f.write(str(testkeys[i])+","+str(testres[i])+"\n")
f.close()
print("training data size:",len(trainkeys))
print("development data size:",len(devkeys))
print("testing data size:",len(testkeys))

import codecs
import os
minkey=1000
maxkey=9999
keynum=3000
current_path=os.path.abspath(os.curdir)
f=codecs.open(os.path.join(current_path,"data_train.csv"), "r", "utf-8")
strlist=f.read().split("\n")
f.close()
trainkeys=[]
trainres=[]
for ele in strlist:
    temp=ele.split(",")
    if len(temp)!=2:
        continue
    trainkeys.append(int(temp[0]))
    trainres.append(int(temp[1]))
f=codecs.open(os.path.join(current_path,"data_dev.csv"), "r", "utf-8")
strlist=f.read().split("\n")
f.close()
devkeys=[]
devres=[]
for ele in strlist:
    temp=ele.split(",")
    if len(temp)!=2:
        continue
    devkeys.append(int(temp[0]))
    devres.append(int(temp[1]))
f=codecs.open(os.path.join(current_path,"data_test.csv"), "r", "utf-8")
strlist=f.read().split("\n")
f.close()
testkeys=[]
testres=[]
for ele in strlist:
    temp=ele.split(",")
    if len(temp)!=2:
        continue
    testkeys.append(int(temp[0]))
    testres.append(int(temp[1]))

# It is very time and space consuming to build models based on the entire dataset
# Instead, we divide the dataset into 3 parts (training, dev, testing)
# We build and train models based on training set, and give index predictions based on testing set

trainkeys.extend(devkeys)
trainres.extend(devres)
trainkeys.extend(testkeys)
trainres.extend(testres)

print("training data size:",len(trainkeys))
print("development data size:",len(devkeys))
print("testing data size:",len(testkeys))

"""## Regression Models

### Build a Linear Regression Model
"""

from sklearn.linear_model import LinearRegression
import numpy as np
from sklearn.metrics import mean_squared_error 
import math
import time
print("Linear Regression Model")
t1=time.time()
reg = LinearRegression()
reg.fit(np.array(trainkeys).reshape(-1,1),np.array(trainres).reshape(-1,1))
t2=time.time()
time_interval=t2-t1
print("time interval for building model:"+str(time_interval*1000)+" ms")
devpre=reg.predict(np.array(devkeys).reshape(-1,1)).reshape(1,-1).tolist()[0]
for i in range(0,len(devpre)):
    devpre[i]=abs(int(devpre[i]))
mse_LR=mean_squared_error(devres,devpre)
print("MSE dev: ",mse_LR)
t1=time.time()
testpre=reg.predict(np.array(testkeys).reshape(-1,1)).reshape(1,-1).tolist()[0]
for i in range(0,len(testpre)):
    testpre[i]=abs(int(testpre[i]))
t2=time.time()
time_interval=t2-t1
print("time interval for indexing data :"+str(time_interval*1000)+" ms")
print("average time interval for indexing data :"+str(time_interval/len(testkeys)*1000)+" ms")
# print("log MSE test: ",round(math.log(1+mean_squared_error(testres,testpre),2),3))

import matplotlib.pyplot as plt
x=np.array(trainkeys).reshape(-1,1)
y=np.array(trainres).reshape(-1,1)
x1=np.array([0, 2147483647]).reshape(-1,1)
y1=reg.predict(x1)
plt.plot(x, y, 'r.',markersize =1)
plt.title('linear regression')
plt.xlabel('x')
plt.ylabel('y')
plt.axis([0, 2147483647, 0, 5000000])
plt.grid(True)
plt.plot(x1, y1,label = 'linear',lw=1)
plt.legend()

import matplotlib.pyplot as plt
x=np.array(devkeys).reshape(-1,1)
y=np.array(devres).reshape(-1,1)
x1=np.array([0, 2147483647]).reshape(-1,1)
y1=reg.predict(x1)
plt.plot(x, y, 'r.',markersize =1)
plt.title('linear regression')
plt.xlabel('x')
plt.ylabel('y')
plt.axis([0, 2147483647, 0, 5000000])
plt.grid(True)
plt.plot(x1, y1,label = 'linear',lw=1)
plt.legend()

from sklearn.externals import joblib
joblib.dump(reg, "linear_regression.model")
model = joblib.load("linear_regression.model")
results = model.predict(np.array(testkeys).reshape(-1,1)).reshape(1,-1).tolist()[0]
for i in range(0,len(results)):
    results[i]=abs(int(results[i]))
print(results)
print(testres)

"""### Build a SVR model"""

# from sklearn.svm import SVR
# print("Support Vector Regression Model")
# clf_best=None
# hp_best={}
# best_mse=9999.99
# for kernel_ in ['rbf', 'sigmoid']:
#     for gamma_ in [1e-4, 1e-3, 0.01, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0]:
#         for C_ in [1, 3, 5, 10, 30, 50, 100, 300, 500, 1000, 3000, 5000, 10000, 30000, 50000]:
#             clf = SVR(kernel=kernel_,gamma=gamma_,C=C_)
#             clf.fit(np.array(trainkeys).reshape(-1,1),np.array(trainres).reshape(-1,1))
#             devpre=clf.predict(np.array(devkeys).reshape(-1,1)).reshape(1,-1).tolist()[0]
#             for i in range(0,len(devpre)):
#                 devpre[i]=abs(int(devpre[i]))%keynum
#             mse_SVR=mean_squared_error(devres,devpre)
#             print("hyper-parameters: ",{'kernel':kernel_,'gamma':gamma_,'C':C_},"log MSE: ",round(math.log(mse_SVR,2),3))
#             if mse_SVR<best_mse:
#                 best_mse=mse_SVR
#                 hp_best={'kernel':kernel_,'gamma':gamma_,'C':C_}
#                 clf_best=clf
# print("hyper-parameters of best model:",hp_best,"log MSE: ",round(math.log(best_mse,2),3))

"""- SVR: kernel=linear"""

from sklearn.svm import SVR
import numpy as np
from sklearn.metrics import mean_squared_error 
import math
import time
print("Support Vector Regression Model: kernel=linear")
t1=time.time()
clf = SVR(kernel='linear')
clf.fit(np.array(trainkeys).reshape(-1,1),np.array(trainres).reshape(-1,1))
t2=time.time()
time_interval_1=t2-t1
print("time interval for building model:"+str(time_interval_1*1000)+" ms")
t1=time.time()
devpre=clf.predict(np.array(devkeys).reshape(-1,1)).reshape(1,-1).tolist()[0]
for i in range(0,len(devpre)):
    devpre[i]=abs(int(devpre[i]))%keynum
MSE_linear=round(math.log(1+mean_squared_error(devres,devpre),2),3)
print("log MSE dev: ",MSE_linear)
t2=time.time()
time_interval_2=t2-t1
print("time interval for indexing data:"+str(time_interval_2*1000)+" ms")
time_interval_linear=time_interval_1+time_interval_2

"""- SVM: kernel=poly"""

from sklearn.svm import SVR
import numpy as np
from sklearn.metrics import mean_squared_error 
import math
import time
print("Support Vector Regression Model: kernel=poly")
t1=time.time()
clf = SVR(kernel='poly')
clf.fit(np.array(trainkeys).reshape(-1,1),np.array(trainres).reshape(-1,1))
t2=time.time()
time_interval_1=t2-t1
print("time interval for building model:"+str(time_interval_1*1000)+" ms")
devpre=clf.predict(np.array(devkeys).reshape(-1,1)).reshape(1,-1).tolist()[0]
for i in range(0,len(devpre)):
    devpre[i]=abs(int(devpre[i]))%keynum
MSE_poly=round(math.log(1+mean_squared_error(devres,devpre),2),3)
print("log MSE dev: ",MSE_poly)
t1=time.time()
testpre=clf.predict(np.array(testkeys).reshape(-1,1)).reshape(1,-1).tolist()[0]
for i in range(0,len(testpre)):
    testpre[i]=abs(int(testpre[i]))%keynum
t2=time.time()
time_interval_2=t2-t1
print("time interval for indexing data:"+str(time_interval_2*1000)+" ms")
time_interval_poly=time_interval_1+time_interval_2

"""- SVM: kernel=rbf"""

from sklearn.svm import SVR
import numpy as np
from sklearn.metrics import mean_squared_error 
import math
import time
print("Support Vector Regression Model: kernel=rbf")
t1=time.time()
clf = SVR(kernel='rbf')
clf.fit(np.array(trainkeys).reshape(-1,1),np.array(trainres).reshape(-1,1))
t2=time.time()
time_interval_1=t2-t1
print("time interval for building model:"+str(time_interval_1*1000)+" ms")
devpre=clf.predict(np.array(devkeys).reshape(-1,1)).reshape(1,-1).tolist()[0]
for i in range(0,len(devpre)):
    devpre[i]=abs(int(devpre[i]))%keynum
MSE_rbf=round(math.log(1+mean_squared_error(devres,devpre),2),3)
print("log MSE dev: ",MSE_rbf)
t1=time.time()
testpre=clf.predict(np.array(testkeys).reshape(-1,1)).reshape(1,-1).tolist()[0]
for i in range(0,len(testpre)):
    testpre[i]=abs(int(testpre[i]))%keynum
t2=time.time()
time_interval_2=t2-t1
print("time interval for indexing data:"+str(time_interval_2*1000)+" ms")
time_interval_rbf=time_interval_1+time_interval_2

"""- SVM: kernel=sigmoid"""

from sklearn.svm import SVR
import numpy as np
from sklearn.metrics import mean_squared_error 
import math
import time
print("Support Vector Regression Model: kernel=sigmoid")
t1=time.time()
clf = SVR(kernel='sigmoid')
clf.fit(np.array(trainkeys).reshape(-1,1),np.array(trainres).reshape(-1,1))
t2=time.time()
time_interval_1=t2-t1
print("time interval for building model:"+str(time_interval_1*1000)+" ms")
devpre=clf.predict(np.array(devkeys).reshape(-1,1)).reshape(1,-1).tolist()[0]
for i in range(0,len(devpre)):
    devpre[i]=abs(int(devpre[i]))%keynum
MSE_sigmoid=round(math.log(1+mean_squared_error(devres,devpre),2),3)
print("log MSE dev: ",MSE_sigmoid)
t1=time.time()
testpre=clf.predict(np.array(testkeys).reshape(-1,1)).reshape(1,-1).tolist()[0]
for i in range(0,len(testpre)):
    testpre[i]=abs(int(testpre[i]))%keynum
t2=time.time()
time_interval_2=t2-t1
print("time interval for indexing data:"+str(time_interval_2*1000)+" ms")
time_interval_sigmoid=time_interval_1+time_interval_2

import matplotlib.pyplot as plt
import numpy as np
from sklearn.metrics import mean_squared_error 
import math
import time
kernels_list = ['linear','poly','rbf','sigmoid']
MSE_list = [MSE_linear, MSE_poly, MSE_rbf, MSE_sigmoid]
plt.title('SVM-MSE(log)')
plt.bar(range(len(MSE_list)), MSE_list,color='b', tick_label=kernels_list)
plt.show()

import matplotlib.pyplot as plt
kernels_list = ['linear','poly','rbf','sigmoid']
time_interval_list = [time_interval_linear, time_interval_poly, time_interval_rbf, time_interval_sigmoid]
plt.title('SVM-Time Complexity(ms)')
plt.bar(range(len(time_interval_list)), time_interval_list,color='b', tick_label=kernels_list)
plt.show()